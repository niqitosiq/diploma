В данной главе будет представлен обзор различных методов оптимизации производительности React-приложений. Важно понимать, что не все методы оптимизации подходят для каждого случая, и выбор оптимального подхода зависит от конкретных требований и контекста приложения. 

### 4.1. Использование React.memo

`React.memo` - это высокоуровневый API, предоставляемый библиотекой React для предотвращения ненужных ререндеров функциональных компонентов.

В функциональных компонентах React, по умолчанию, компонент будет повторно отрендерен при каждом изменении пропсов или состояния. Это означает, что при каждом таком изменении вызывается функция компонента, и функция рендеринга возвращает новое дерево React-элементов. Это новое дерево затем сравнивается с предыдущим деревом элементов для определения, какие изменения следует применить к DOM.

`React.memo` оборачивает функциональный компонент и добавляет поверхностное сравнение пропсов перед каждым рендером. Если пропсы не изменились, React будет переиспользовать последний результат рендеринга, предотвращая ненужное создание новых элементов и сравнение с предыдущим деревом.

Однако стоит отметить, что использование `React.memo` не всегда является лучшим решением. В некоторых случаях, время и ресурсы, затраченные на сравнение пропсов, могут превысить время и ресурсы, сэкономленные на предотвращении повторного рендеринга. Это особенно верно для простых компонентов, где сам процесс рендеринга является относительно быстрым.

Поскольку React изначально проводит сравнение пропсов, не всегда имеет смысл явно использовать React.memo, лучше использовать useMemo для контроля над изменением ссылочного объекта, который приводит к ненужному ререндеру.

### 4.2. useMemo и useCallback
`useMemo` и `useCallback` - это хуки, предоставляемые библиотекой React, которые помогают оптимизировать производительность функциональных компонентов путем мемоизации.

##### 4.2.1. useMemo
`useMemo` возвращает мемоизированное значение, которое пересчитывается только тогда, когда изменяются его зависимости.

```jsx
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
```

В этом примере, `computeExpensiveValue` - это дорогостоящая функция, которую мы не хотим вызывать при каждом рендере. `useMemo` помогает нам избежать этого, вызывая `computeExpensiveValue` только когда меняются `a` или `b`.

Однако, использование `useMemo` не бесплатно. Оно занимает ресурсы для отслеживания зависимостей и хранения мемоизированного значения. В некоторых случаях, затраты на использование `useMemo` могут превышать затраты на вызов функции `computeExpensiveValue` при каждом рендере. Поэтому использование `useMemo` рекомендуется только тогда, когда функция действительно "дорогостоящая".

##### 4.2.2. useCallback

`useCallback` возвращает мемоизированную версию переданной ему функции, которая изменяется только тогда, когда меняются ее зависимости.

```jsx
const memoizedCallback = useCallback(() => {
  doSomething(a, b);
}, [a, b]);
```

В этом примере, `doSomething` вызывается только тогда, когда `a` или `b` меняются. Это может быть полезно, когда `memoizedCallback` передается в дочерний компонент в качестве пропа. Без `useCallback`, дочерний компонент бы перерендеривался каждый раз, когда родительский компонент рендерится, так как функция `doSomething` бы создавалась заново при каждом рендере.

Однако, как и в случае с `useMemo`, использование `useCallback` также занимает ресурсы для отслеживания зависимостей и хранения мемоизированной функции. Поэтому его следует использовать только тогда, когда эта оптимизация действительно необходима. 

#### 4.2.3 Когда мемоизация необходима?
Для того, чтобы определить, в каких случаях использование  мемоизация становится целесообразной, можем определить операции, выполняемые в исходном коде одного из хуков. Для примера разберем useMemo

##### **Анализ кода `useMemo` из библиотеки React**

Код `useMemo` из библиотеки React обычно выглядит следующим образом:

```jsx
function useMemo(factory, deps) {
  const hook = nextHook();
  const nextInputs = deps !== undefined ? deps : null;

  if (hook !== null && hook.memoizedState !== null) {
    const prevInputs = hook.memoizedState[1];
    if (areHookInputsEqual(nextInputs, prevInputs)) {
      return [hook.memoizedState[0]];
    }
  }

  const nextValue = factory();
  hook.memoizedState = [nextValue, nextInputs];
  return [nextValue];
}
```

В этом коде происходит следующее:

1. Создается новый хук с помощью функции `nextHook()`.

2. Проверяется, существует ли предыдущее состояние хука и были ли изменены зависимости.

3. Если зависимости не изменились, возвращается предыдущее значение.

4. Если зависимости изменились, вызывается функция `factory()` для вычисления нового значения, которое затем сохраняется в состоянии хука.

Каждый из этих шагов требует некоторого количества процессорного времени и памяти. Например, функция `areHookInputsEqual()` должна выполнить сравнение массивов зависимостей, а `factory()` - вычисление нового значения. Память используется для хранения состояния хука и возвращаемого значения.

Определить точное количество операций и объем памяти, которые требуются для `useMemo`, в общем случае сложно, так как это зависит от многих факторов, включая размер массива зависимостей и сложность функции `factory`. Однако, мы можем грубо оценить, что каждый вызов `useMemo` требует выполнения следующих операций:

1. Создание нового объекта для хранения состояния хука.
2. Поверхностное сравнение массивов зависимостей (при наличии).
3. Вызов функции `factory` и сохранение ее результата.

Каждая из этих операций требует некоторого количества памяти и процессорного времени. В среднем, мы можем сказать, что `useMemo` будет требовать больше ресурсов, чем простой вызов функции, но меньше, чем перерендеринг всего компонента.

В целом, если функция, которую мы хотим мемоизировать, очень "дорогостоящая" и вызывается при каждом рендере, использование `useMemo` может быть оправдано. Однако, если функция недорогая, или ее вызовы редки, использование `useMemo` может быть избыточным и даже привести к снижению производительности из-за дополнительных затрат на отслеживание зависимостей и хранение мемоизированных значений.

С другой стороны, `useMemo` может быть полезным, когда мы хотим предотвратить ненужные ререндеры дочерних компонентов, которые зависят от пропсов, создаваемых в родительском компоненте. В этом случае, `useMemo` может помочь избежать создания новых объектов или массивов при каждом рендере, что приводит к ненужным ререндерам дочерних компонентов. 

Однако, такие сценарии довольно специфичны и в большинстве приложений встречаются редко. Поэтому важно подходить к использованию `useMemo` и других оптимизационных техник с умом, учитывая не только потенциальные преимущества, но и возможные негативные последствия для производительности и читаемости кода.

### 4.3. Lazy loading и Suspense

В React есть возможность использовать механизмы ленивой загрузки и ожидания для оптимизации загрузки и рендеринга компонентов. `React.lazy` позволяет определить компонент, который будет загружаться только тогда, когда он потребуется, а `Suspense` — отображать запасной контент, пока ожидается загрузка компонентов. В этом разделе мы рассмотрим, как использовать эти механизмы для улучшения производительности приложения.

### 4.3. Lazy loading и Suspense

#### 4.3.1. Lazy Loading

Lazy loading, или "ленивая загрузка", это техника, позволяющая откладывать инициализацию или загрузку объекта до тех пор, пока он не понадобится. Это может помочь улучшить производительность приложения, особенно когда речь идет о загрузке больших библиотек, модулей или компонентов.

React предлагает встроенную поддержку lazy loading с использованием функции `React.lazy`. Эта функция позволяет динамически загружать компоненты как обычные модули JavaScript с использованием синтаксиса import. Применение `React.lazy` вместе с динамическим импортом позволяет React автоматически разделить код и загружать компоненты только когда они реально необходимы.

Пример использования `React.lazy`:

```jsx
const LazyComponent = React.lazy(() => import('./LazyComponent'));

function MyComponent() {
  return (
    <div>
      <Suspense fallback={<div>Loading...</div>}>
        <LazyComponent />
      </Suspense>
    </div>
  );
}
```

В этом примере `LazyComponent` будет загружен только когда `<LazyComponent />` будет впервые отрендерен.

#### 4.3.2. Suspense

Suspense – это компонент React, предназначенный для "задержки" рендеринга дочерних компонентов, пока не будет выполнено некоторое условие. Он часто используется в связке с `React.lazy` для отображения запасного контента (fallback), пока происходит загрузка ленивого компонента.

Suspense может использоваться не только для ленивой загрузки компонентов, но и для других асинхронных операций, таких как загрузка данных. React также работает над новыми возможностями Suspense, которые обещают упростить обработку асинхронных операций в React-приложениях, включая отображение загрузчика (loader), автоматическую обработку ошибок и более гибкую работу с приоритетами.

Важно отметить, что для некоторых сценариев, таких как серверный рендеринг, использование `React.lazy` и `Suspense` может быть сложным или даже невозможным без дополнительных библиотек или фреймворков. В этих случаях могут быть полезны другие инструменты и подходы, такие как динамический импорт на уровне маршрута или использование библиотеки, как Next.js.


#### 4.5. Дополнительные практики для избегания проблем с производительностью

В этом разделе будут представлены рекомендации и принципы, которые могут помочь избежать проблем с производительностью при разработке веб-приложений на React. 

1.  **Оптимизируйте большие списки**: Если у вас есть большие списки, которые могут вызывать проблемы с производительностью, используйте техники виртуализации списка или ленивой загрузки. 
2. **Используйте ключи в списках**: Всегда используйте уникальные и стабильные ключи при рендере списков в React. Это помогает React определить, какие элементы списка были изменены, добавлены или удалены, и обновлять только измененные элементы.
3. **Оптимизация состояния**: Используйте подходы, такие как использование `useReducer` и Context для управления сложными состояниями и предотвращения ненужных рендеров.
4. **Избегайте анонимных функций в JSX**: Анонимные функции создаются заново при каждом рендере, что может вызывать ненужные рендеры дочерних компонентов. Вместо этого используйте именованные функции или `useCallback`.
5. Избегайте создания объектов внутри функции компонента -- **дописать!**