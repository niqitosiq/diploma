В данной главе будет представлен подробный обзор основных хуков, используемых при работе с функциональными компонентами в React. Хуки позволяют использовать состояние и другие возможности React без написания классовых компонентов, что делает код более лаконичным и удобным для чтения и поддержки.

### **3.1. useState**
Хук `useState` является одним из основных и наиболее часто используемых хуков в библиотеке React. Он позволяет создавать и управлять состоянием внутри функционального компонента.

```jsx
const [state, setState] = useState(initialState);
```

В этом коде `initialState` — это начальное значение состояния, `state` — текущее значение состояния, а `setState` — функция, которая позволяет изменять это состояние.

При вызове функции `setState` с новым значением состояния React запланирует повторный рендер компонента. Это означает, что каждое изменение состояния, управляемого с помощью `useState`, приведет к дополнительному рендеру компонента.

Важно понимать, что хотя `setState` и вызывает ререндер, это не всегда означает, что DOM будет обновлен. React использует алгоритм сравнения, который позволяет определить, изменился ли реально выводимый компонент, и если нет, то обновление DOM не происходит. 

Однако, несмотря на это, каждый ререндер — это дополнительные вычисления и потенциальные затраты ресурсов, поэтому стоит стремиться минимизировать количество ререндеров, особенно в случае высоконагруженных пользовательских интерфейсов.

Можно управлять количеством ререндеров, аккуратно используя `setState`, обновляя состояние только тогда, когда это действительно необходимо. Например, проверяя, изменилось ли новое значение по сравнению с текущим, перед вызовом `setState`.

Также стоит отметить, что `useState` не гарантирует "глубокого" сравнения при обновлении состояния. Если состояние — это объект или массив, то React будет сравнивать их по ссылке, а не по содержанию. Это может привести к нежелательным ререндерам, если не учитывать эту особенность при работе с состоянием.

### **3.1.1. useRef**

`useRef` — это ещё один хук, предоставляемый библиотекой React. Он позволяет создать "реф", то есть ссылку на некоторое изменяемое значение, которое может сохраняться между рендерами без вызова ререндера.

```jsx
const ref = useRef(initialValue);
```

В этом коде `initialValue` — это начальное значение рефа, а `ref.current` — текущее значение рефа.

Рефы часто используются для доступа к DOM-элементам, но они также могут использоваться для хранения любых изменяемых значений.

Основное отличие `useRef` от `useState` заключается в том, что изменение `ref.current` не вызывает ререндер. Это делает `useRef` полезным для хранения значений, которые необходимы для работы компонента, но не должны вызывать его обновление.

Например, если у вас есть таймер или интервал внутри компонента, идентификатор этого таймера или интервала может быть сохранён в рефе. Изменение этого идентификатора не должно вызывать ререндер компонента, так как это не влияет на то, что отображается на экране.

```jsx
const timerIdRef = useRef();

useEffect(() => {
  timerIdRef.current = setInterval(() => {
    // Некоторые действия
  }, 1000);

  return () => {
    clearInterval(timerIdRef.current);
  };
}, []);
```

В этом примере `timerIdRef.current` используется для хранения идентификатора интервала. Изменение `timerIdRef.current` не вызывает ререндер, что делает код более эффективным с точки зрения производительности.

Однако стоит помнить, что, поскольку изменение `ref.current` не вызывает ререндер, React не будет автоматически "отслеживать" эти изменения. Это значит, что если значение, хранящееся в рефе, используется в рендере, компонент может отображаться некорректно. Поэтому `useRef` следует использовать только для значений, которые не влияют на результат рендера.

###  **3.2. useEffect**

`useEffect` — это хук, который позволяет выполнять побочные эффекты в функциональном компоненте. Эффекты могут включать в себя запросы к API, подписки, таймеры и другие операции, которые должны выполняться после отрисовки компонента.

```javascript
useEffect(() => {
  // Здесь выполняются побочные эффекты

  return () => {
    // Здесь выполняется очистка эффектов (например, отписка от событий)
  };
}, [dependencies]);
```

`useEffect` принимает функцию, которая выполняет побочные эффекты, и массив зависимостей. Если массив зависимостей пуст, эффекты выполняются только один раз при монтировании и размонтировании компонента. Если в массиве указаны переменные, то эффекты будут выполняться при их изменении.

### **3.3. useContext**

`useContext` — это хук, который позволяет использовать контекст в функциональном компоненте. Контекст позволяет передавать данные через дерево компонентов без необходимости передачи пропсов на каждом уровне. 

```javascript
const contextValue = useContext(MyContext);
```

В данном примере `MyContext` — это объект контекста, созданный с помощью `React.createContext()`, а `contextValue` — это значение контекста, которое может быть использовано в компоненте. Полезно, при передачи состояния в компонентах с глубокой и сложной структурой.

### **3.4. useMemo и useCallback**

`useMemo` и `useCallback` — это хуки, которые позволяют оптимизировать производительность при работе с функциями и вычисляемыми данными.

`useMemo` возвращает мемоизированное значение:

```javascript
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
```

В данном примере `computeExpensiveValue(a, b)` — это функция, выполняющая сложные вычисления. `useMemo` гарантирует, что эта функция будет вызвана только при изменении `a` или `b`.

`useCallback` возвращает мемоизированную версию переданной ему функции:

```javascript
const memoizedCallback = useCallback(() => {
  doSomething(a, b);
}, [a, b]);
```

В данном примере `doSomething(a, b)` — это функция, которую нужно выполнить. `useCallback` гарантирует, что новая функция будет создана только при изменении `a` или `b`.

В заключении, можно сказать, что хуки в React — это мощный инструмент для управления состоянием, побочными эффектами и другими возможностями функциональных компонентов. Они делают код более чистым, понятным и масштабируемым, что существенно упрощает разработку и поддержку сложных веб-приложений.

#### **3.4.1. Хук useMemo**

Хук useMemo позволяет нам выполнять "тяжёлые" вычисления при рендере компонента только в том случае, если зависимости этих вычислений изменились. 

```jsx
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
```

В этом коде `computeExpensiveValue` — это функция, выполняющая сложные вычисления на основе переменных `a` и `b`. useMemo будет вызывать эту функцию и "запоминать" её результат между рендерами, пока `a` и `b` не изменятся.

Однако стоит отметить, что использование useMemo не бесплатно. Первое исполнение useMemo требует выполнения функции `computeExpensiveValue`, а также занимает дополнительную память для хранения результата. Кроме того, каждый ререндер компонента вызывает проверку на изменение зависимостей, что также требует ресурсов.

####  **3.4.2. Хук useCallback**

Хук useCallback позволяет нам "запомнить" функцию между рендерами, что может быть полезно, если эта функция передаётся в дочерний компонент и используется в списке зависимостей эффекта или другого хука.

```jsx
const memoizedCallback = useCallback(
  () => {
    doSomething(a, b);
  },
  [a, b],
);
```

В этом коде `doSomething` — это функция, которая использует переменные `a` и `b`. useCallback будет "запоминать" эту функцию между рендерами, пока `a` и `b` не изменятся.

Также как и useMemo, useCallback требует ресурсов для своего выполнения. Он занимает дополнительную память для хранения функции и выполняет проверку на изменение зависимостей при каждом рендере.

####  **3.4.3. Когда использовать useMemo и useCallback**

Исходя из вышеуказанного, можно сделать вывод, что использование useMemo и useCallback имеет смысл только тогда, когда затраты на их использование меньше, чем затраты на перевыполнение "тяжёлых" вычислений или функций. Если функция или вычисление требует значительных ресурсов и выполняется при каждом рендере, то использование useMemo или useCallback может улучшить производительность.

Например, если функция `computeExpensiveValue` выполняет сложные математические вычисления и требует значительного времени для их выполнения, то использование useMemo может сэкономить ресурсы, отложив эти вычисления.

Если функция `computeExpensiveValue` выполняет сложные математические вычисления и требует значительного времени для их выполнения, то использование useMemo может сэкономить ресурсы, отложив эти вычисления до момента, когда `a` или `b` изменятся.

Например:

```jsx
const computeExpensiveValue = (a, b) => {
  let result = a;
  for (let i = 0; i < 1000000; i++) {
    result += b * Math.sin(i);
  }
  return result;
};

// В компоненте:
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
```

В данном случае функция `computeExpensiveValue` выполняет миллион итераций цикла, что может занимать значительное время. Использование useMemo позволяет нам выполнить эти вычисления только один раз для каждого уникального набора значений `a` и `b`, а не при каждом рендере.

Таким образом, решение о использовании useMemo или useCallback должно основываться на сравнении затрат на их использование и затрат на перевыполнение вычислений или функций. Если вычисления или функции "дорогие", то использование этих хуков может быть оправданным. Если же они "дешёвые", то использование useMemo и useCallback может быть избыточным и даже ухудшить производительность из-за дополнительных затрат на хранение результатов и проверку зависимостей.

Одной из целей выполнения дипломной работы, будет определить, где проходит грань, когда использования хуков оптимизации является полезным.